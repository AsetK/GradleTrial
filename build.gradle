import com.epam.customtask.CustomTask

import java.time.Duration

plugins { //For tasks tree. To run: gradle someTask taskTree
    id "com.dorongold.task-tree" version "1.4"
}

apply plugin : 'java'


dependencies {
    testCompile 'junit:junit:4.12'
    compile 'org.apache.commons:commons-lang3:3.9'
    compile group: 'commons-lang', name: 'commons-lang', version: '2.6'

}

repositories {
    mavenCentral()
}

//1. Сконфигурировал таску. Что бы System.out работал в тестах.
test {
    testLogging.showStandardStreams=true 
}

//2. Своя таска. sourceSets and configurations
task runMain(type: JavaExec) { //поумолчанию  type: Default

    doFirst {
//        classpath = files(sourceSets.main.output.files) //если в doFirst определить class-path, то второе определение( то что после do first, не сравботает.
//        println classpath.files.collect { it.toURI() }.join('\n')
    }
    //указывает где находиться скомпилированные классы(src) + dependencies.
    // 'com.epam.helloworldgradle.Runner' - скомпилированный класс
    main = 'com.epam.helloworldgradle.Runner'
    classpath = sourceSets.main.runtimeClasspath //или files(sourceSets.main.output.files) - но тогда уже без dependencies, только скомпилированные классы(src)
    doLast {
        println 'Runtime Class-Path - compiled src + dependencies:'
        println sourceSets.main.runtimeClasspath.collect { it.toURI() }.join('\n')
        println '------------------------------------------------------------------------'

        println 'Only main output - compiled src:'
        println sourceSets.main.output.files
        println '------------------------------------------------------------------------'

        println 'Only runtime dependencies:'
        println configurations.runtime.files.collect { it.toURI() }.join('\n')
        println '------------------------------------------------------------------------'

        println 'PatchingJar path:'
        println patchingJar.archivePath
        println '------------------------------------------------------------------------'

        println 'Class-Path:'
        println classpath.files.collect { it.toURI() }.join('\n')
        println '------------------------------------------------------------------------'
        println configurations.testRuntime.files.collect { it.toURI() }.join('\n')
    }
}


//Jar, JavaExec
task patchingJar(type: Jar) { //не executable jar, просто jar т.к. нет main-class. Упаковываем все dependencies в 1 jar.
    dependsOn configurations.runtime  //и без этого работает.
    baseName = "patching-${project.name}" //нужно поменять, что бы название архива отличалось от архива стандартной jar таски
    doFirst {
        manifest {
            attributes "Class-Path": configurations.runtime.files.collect { it.toURI() }.join(' ') //добавляет в classpath runtime dependencies. но без скомпилированных src
            println configurations.runtime.files.collect { it.toURI() }.join('\n')
        }
    }
}

task runExecutableJar(type: JavaExec) {
    // Executable jars can have only _one_ jar on the classpath.
    classpath = files(tasks.jar)

    // 'main' does not need to be specified

    // arguments to pass to the application
    args 'appArg1'
}



//3. Своя таска интегрированная в build lifecycle
task runTest(type: JavaExec, dependsOn: test){ //После чего
    main = 'com.epam.calculator.IntegrationalTest'
    classpath sourceSets.test.runtimeClasspath
}

check.dependsOn.add(runTest) //До чего

//4. Своя таска берущая значение из property. Task Type: Default
task propertyTask{
    println x //Executed in configuration phase
}

//5. Custom таска из buildSrc
task myMessage(type: CustomTask) {
    message = 'My message_1 '
    doLast {
        println 'Executed in execution phase_1'
    }
    doLast {
        println 'Executed in execution phase_1.5'
    }
}


//Конфигурирование таски
myMessage {
    message = 'My message_2 '
    doLast {
        println 'Executed in execution phase_2'
    }
    println "Executed in configuration phase"
}

myMessage.message = "My message_3 "

//6. Dynamic tasks????????????????????????????
4.times {counter -> task "dynamicTask$counter"{
    doLast{
        println "Dynamic Task_$counter"
    }
}
}

//7. Manipulating existing tasks
//Adding a dependency
//dynamicTask3.dependsOn dynamicTask2, dynamicTask1, dynamicTask0


//adding behaviour
task hello{
    doLast {println "Hello Eath"}
    println "Println"
}

hello.doFirst {println "Hello Venus"}

hello.configure {
    doLast {println "Hello Mars"}
}

hello.configure {
    doLast {println "Hello Jupiter"}
}

hello {
    doLast {println "Hello Mercurius"}
}

//8. Ordering tasks
task taskA {
    doLast {println "Task A"}
}

task taskB {
    doLast {println "Task B"}
}

taskB.shouldRunAfter taskA

//9. Adding description to a task
task taskC{
    description "<--------Task C"
    doLast {println "Task C"}
}

//10. Replacing tasks
task taskD {
    doLast {println "Task D1"}
}

task taskD(overwrite:true){
    doLast {println "Task D2"}
}

//11. Skipping task
//11.1 Using predicate
task taskE{
    doLast {println "Task E"}
}

taskE.onlyIf {false}

//11.2 Using StopExecutionException
task taskF {
    doLast {println "Task F"}
}

taskF.doFirst {
    println "Task F do first"
    if (true) { throw new StopExecutionException()}
}

task taskG{
    dependsOn taskF
    doLast {println "Task G is will be Executed"}
}

//11.3 Enabling and disabling tasks

task disableMe {
    doLast {
        println 'This should not be printed if the task is disabled.'
    }
}
disableMe.enabled = false

//11.4 Specifying task timeouts Не работает














//Отключаем втсроенную таску
//Так как build task(lifecycle) содержит в себе phases(как в Maven), они выполняются последовательно, т.е. следующая таска dependsOn от предыдущей(предыдущих, учитывая что это цепочка тасков)
//В Gradle мы можем отключать таски.
//build.dependsOn.remove('check')


